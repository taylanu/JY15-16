package dataStructure;

import java.util.ArrayList;

public class SparseMatrix<anyType> implements Matrixable<anyType> {
    //needs to have util imported.
    //COMMENT.
    private int numRows, numCols;
    private ArrayList<Cell<anyType>> list = new ArrayList<Cell<anyType>>();//create Cells that will contain points


    public SparseMatrix(int r, int c) {
        numRows = r;
        numCols = c;
        list = new ArrayList<Cell<anyType>>();
    }

    @Override
    public String toString() {//prints array ask RevO about 2d
        String str = "";
        for (int r = 0; r < numRows; r++) {
            for (int c = 0; c < numCols; c++) {
                int index = -1;
                for (int i = 0; i < list.size(); i++) {
                    if (((r * numCols) + c) == (((Cell) list.get(i)).getKey())) {
                        str += (((Cell) list.get(i)).getVal());
                        index = i;
                    }
                }
                if (index == -1) {
                    str += "-";
                }
                str += "\t";
            }
            str += "\n";
        }
        return str;
        //autogenerated {{ return "SparseMatrix [numRows=" + numRows + ", numCols=" + numCols + ", list=" + list + "]";
    }

    @Override
    public anyType get(int r, int c) {//complete
        int key = r * numCols + c;
        for (int i = 0; i < list.size(); i++) {
            if (key == ((Cell) list.get(i)).getKey()) {//(temp.getRow()==r && temp.getCol()==c)
                return list.get(i).getVal();
            }
        }
        return null;
    }

    @Override
    public anyType set(int r, int c, anyType x) {
        // temp = null;
        Cell<anyType> temp = new Cell<anyType>(r, c, numCols, x);
        int key = r * numCols + c;
        for (int i = 0; i < list.size(); i++) {
            if (key == ((Cell) list.get(i)).getKey()) {
                anyType replace = list.get(i).getVal();//swap method of sorts
                list.set(i, temp);
                return (replace);
            }
        }
        return null;//should be old value, so build a temp value to store old value
    }


    @Override
    public boolean add(int r, int c, Object x) {
        Cell sub = new Cell(r, c, numCols, x);
        int key = r * numCols + c;
        for (int i = 0; i < list.size(); i++) {
            if (key <= ((Cell) list.get(i)).getKey()) {
                list.add(i, sub);
                return true;
            }
        }
        list.add(sub);
        return true;
    }


    @Override
    public anyType remove(int r, int c) {
        int key = (r * numCols) + c;
        for (int i = 0; i < list.size(); i++) {
            if (key == ((Cell) list.get(i)).getKey()) {
                Object temp = list.get(i).getVal();
                list.remove(i);
                return (anyType) temp;
            }
        }
        return null;
    }


    @Override
    public int size() {
        return list.size();
    }

    @Override
    public int numRows() {
        return numRows;
    }


    @Override
    public int numColumns() {
        return numCols;
    }


    @Override
    public void clear() {
        list.clear();
    }


    @Override
    public boolean contains(anyType x) {
        // TODO Auto-generated method stub
        if (list.contains(x))
            return true;
        return false;
    }

    @Override
    public boolean isEmpty() {
        if (list.isEmpty())
            return true;
        return false;
    }

    @Override
    public int[] getLocation(anyType x) {
        for (int i = 0; i < list.size(); i++)
            if (list.get(i) == x)
                return null;
        return null;
    }


    @Override
    public void setBlank(char blank) {//what do I need to set blank
        /*for(int r=0;r<list.size();r++)
			for(int c)*/
    }

    @Override
    public Object[][] toArray() {
        // TODO Auto-generated method stub
        return null;
    }
}

/*
public Object[][] toArray() {//prints array
Object[][] array = new Object[numRows][numCols];
  for(int r = 0; r < numRows; r++){
     for(int c = 0; c < numCols; c++){
        if(exists(r,c))
           array[r][c] = get(r,c);
        else
           array[r][c] = null;
     }
  }  
  return array;
}
public boolean exists(int r, int c)//Is there any object at this point?
{
  int key = r * numCols + c;
  for(int i = 0; i < list.size(); i++){
     if(key == ((Cell)list.get(i)).getKey()){
        return true;
     } 
  }
  return false;
}
*/